<!DOCTYPE html>
<html lang="ja">
<!-- HTML ケバブケース 変数は使う処理の近くに宣言 変数はローワーキャメルケース  camelCase-->
<!-- wrapper ＞ container ＞ content ※Contentsはリストを囲む場合など-->
<!-- 基本idを使う class -->
<!-- 特殊な要素の命名は、要素名をいれる  label-img-import-->

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta property="og:description" content="試作品" />
	<title>Beyblade Profile Card Generator</title>
</head>

<body>
	<div id="wrapper">
		<div id="main-container">
			<div id="left-content">
				<img id="result-img" alt="テンプレート画像" width="900px">
				<form id="textform">
					<input type="text" id="input-blader-name" placeholder="ここに文字を入力" />
					<input type="text" id="input-age" placeholder="例：20代後半" />
					<input type="text" id="input-gender" placeholder="例：男性" />
					<input type="text" id="input-location" placeholder="例：福岡市周辺" />
					<input type="text" id="input-generation" placeholder="例：メタベイ、ベイブレードX" />
					<input type="text" id="input-max-power" placeholder="例：1万" />
					<input type="text" id="input-launcher" placeholder="例：ロングワインダー派" />
					<input type="text" id="input-tournament" maxlength="7" placeholder="最大7文字まで" />
					<textarea rows="4" id="input-free-comment" cols="20" placeholder="例：まずはゆるく繋がれるとうれしいです"></textarea>
				</form>
				<div id="img-import-content">
					<label for="input-img-import" id="label-img-import">アイコン画像を選択</label>
					<input type="file" id="input-img-import" style="display: none;"><br>
				</div>
			</div>
			<div id="right-content">
				<div id="colorpicker-wrapper">
					<label for="colorpicker" id="colorpicker-label">文字色を選択: </label>
					<input type="color" id="colorpicker" value="#3bbcdc" />
				</div>
				<div id="fontselector-wrapper">
					<label for="fontselector">フォントを選択：</label>
					<select id="fontselector">
						<option value="'Helvetica Neue', 'Helvetica', 'Hiragino Sans', 'Arial', 'Yu Gothic', 'Meiryo', sans-serif">ゴシック体</option>
						<option value="'Times New Roman', 'YuMincho', 'Hiragino Mincho ProN', 'Yu Mincho', 'MS PMincho', serif">明朝体</option>
						<option value="DotWeb">ドット</option>
					</select>
				</div>
				<div id="button-content">
					<button type="button" id="generate-button">確定</button>
					<button type="button" id="re-edit-button" style="display: none;">再編集</button>
					<button type="button" id="download-button" style="display:none;"><a id="downloadlink" download="image.png">ダウンロード</a></button>
				</div>
			</div>
		</div>
		<div id="modal-container" style="display: none;" class="modal">
			<div id="modal-content">
				<div id="modal-header">
					<h1>プロフィール画像に使う部分を選択してください</h1>
					<span id="modal-close-button">&times;</span>
				</div>
				<div id="modal-body">
					<canvas id="canvas-modal" width="100%"></canvas>
					<button id="crop-button">確定</button>
					<canvas id="resultCanvas" style="display: none;"></canvas>
					<img id="preview">
				</div>
			</div>
		</div>
	</div>
</body>

<!-- ↓このページ独自のJS追加 -->
<script>

	const canvas = document.createElement('canvas');//この時点ではJavaScriptのメモリ上で生成する。HTMLツリー（DOM）には出現しない
	const ctx = canvas.getContext('2d');


	//初期画像処理
	const imgSrc = "https://shinamoso.github.io/RepositoryForVSCode/img/02-prf.png"; // 元画像のURL
	const resultImg = document.getElementById('result-img');
	// const imgSrc = "/img/test.png"; // test用画像のURL
	resultImg.src = imgSrc;// 画像表示


	//プロフィールアイコン読み込み処理
	const inputImg = document.getElementById('input-img-import');
	const imgInputLabel = document.getElementById('label-img-import');


	//モーダル関数
	const modalBackground = document.getElementById('modal-container');
	const modalCloseBtn = document.getElementById('modal-close-button');

	//モーダルのバツ印がクリックされた時
	modalCloseBtn.addEventListener('click', modalClose);
	function modalClose() {
		modalBackground.style.display = 'none';
	}

	modalBackground.addEventListener('click', outsideClose);//modalBackground.addEventListenerだと子要素も拾ってしまうため、if文で条件分岐する
	function outsideClose(e) {
		if (e.target == modalBackground) { //e.target イベントが発生した要素（子要素含む）を取得しmodalBackgroundの要素と同じ場合実行 すなわちモーダルの背景部分がクリックされたとき実行
			modalBackground.style.display = 'none';//子要素も自動的に消える（継承ではなくそのような仕様）
		}
	};


	//画像選択時の処理
	const canvasModal = document.getElementById('canvas-modal');
	const ctxModal = canvasModal.getContext('2d');
	const resultCanvas = document.getElementById('resultCanvas');
	const resultCtx = resultCanvas.getContext('2d');

	inputImg.addEventListener('change', (e) => {
		if (inputImg.files.length > 0) {
			imgInputLabel.textContent = '選択済み✅';
		} else {
			imgInputLabel.textContent = 'アイコン画像を選択';
		}

		//モーダルを表示
		modalBackground.style.display = 'block';

		const modalBody = document.getElementById('modal-body');
		const HorizontalPadding = parseFloat(window.getComputedStyle(modalBody).paddingRight)*2;//モーダルの横の余白を取得
		let drawWidth = modalBody.clientWidth - HorizontalPadding;

		const ModalContent = document.getElementById('modal-content');
		const ModalHeader = document.getElementById('modal-header');
		const VerticalMargin = parseFloat(window.getComputedStyle(ModalContent).marginTop)*2+parseFloat(window.getComputedStyle(ModalHeader).height)*2;//モーダルの縦の余白を取得
		let maxHeight = window.innerHeight-VerticalMargin;
		let drawHeight;

		const file2 = e.target.files[0];
		if (!file2) return;
		const reader = new FileReader();
		let img = new Image();

		//選択画像が読み込まれたら実行
		reader.onload = event => {
			img.src = event.target.result;//読み込んだ画像（Base64エンコードされた文字列）をsrcに設定
			img.onload = () => {

				//モーダル内に表示するCanvasサイズを調整
				canvasModal.width = drawWidth;

				// 画像の縦横比とコンテナの縦横比を計算
				const imgRatio = img.width / img.height;
				// const containerRatio = drawWidth / maxHeight;

				// Canvasの高さをCanvasの横幅を元に算出（画像の比率と同じになるようにする）
				drawHeight = drawWidth / imgRatio;

				// Canvasサイズを描画サイズに合わせて設定
				canvasModal.height = drawHeight;

				// もし高さがコンテナの高さを超える場合は、高さをコンテナに合わせて、幅を調整
				if (drawHeight > maxHeight) {
					drawHeight = maxHeight;
					canvasModal.height = drawHeight;
					drawWidth = drawHeight * imgRatio;
					canvasModal.width = drawWidth;
				}

				draw();
			};
		};
		reader.readAsDataURL(file2);//Data URL形式（Base64エンコードされた文字列）にする onloadのイベントハンドラを登録してから記載する

		let cropRect = { x: 50, y: 50, w: 400, h: 400 };//オブジェクト;
		let handleSize = 12;

		//スマホ表示時は初期トリミング範囲を小さくしてハンドルサイズを大きくする
		if (document.documentElement.clientWidth < 767) {
			cropRect = { x: 50, y: 50, w: 100, h: 100 };//オブジェクト
			handleSize = 24;
		};

		//トリミング範囲の矩形
		let isDragging = false;
		let dragOffsetX = 0;
		let dragOffsetY = 0;
		let isResizing = false;
		let resizeDir = '';

		function draw() {
			//念のためクリアしてから描画
			ctxModal.clearRect(0, 0, canvasModal.width, canvasModal.height);
			ctxModal.drawImage(img, 0, 0, drawWidth, drawHeight);

			// トリミング範囲を描画
			ctxModal.fillStyle = 'rgba(0, 0, 255, 0.3)';//塗りつぶしの色
			ctxModal.fillRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);//塗りつぶしの四角形を描画
			ctxModal.strokeStyle = 'blue';//枠線の色
			ctxModal.lineWidth = 2;
			ctxModal.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);//枠線を描画

			// Draw handles (四隅＋4辺) //getAllHandles()で配列を取得してforEachで繰り返し
			getAllHandles().forEach(h => drawHandle(h.x, h.y));
		}

		//ハンドル＝トリミング範囲の小さい8つの四角形を描画
		function drawHandle(x, y) {
			ctxModal.fillStyle = 'white';
			ctxModal.strokeStyle = 'blue';
			ctxModal.lineWidth = 2;
			ctxModal.beginPath();
			ctxModal.rect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
			ctxModal.fill();//塗りつぶし
			ctxModal.stroke();
		}

		function getAllHandles() {
			const x = cropRect.x, y = cropRect.y, w = cropRect.w, h = cropRect.h;
			//nwの命名はnorth west（北西）トリミングボックスのハンドル部分をを計算
			return [//配列にオブジェクトが入っている
				{ dir: 'nw', x: x, y: y },
				{ dir: 'n', x: x + w / 2, y: y },
				{ dir: 'ne', x: x + w, y: y },
				{ dir: 'e', x: x + w, y: y + h / 2 },
				{ dir: 'se', x: x + w, y: y + h },
				{ dir: 's', x: x + w / 2, y: y + h },
				{ dir: 'sw', x: x, y: y + h },
				{ dir: 'w', x: x, y: y + h / 2 },
			];
		}

		const directionToCursor = {
			'n': 'n-resize',
			'e': 'e-resize',
			's': 's-resize',
			'w': 'w-resize',
			'ne': 'ne-resize',
			'nw': 'nw-resize',
			'se': 'se-resize',
			'sw': 'sw-resize'
		};

		function getHandleAt(x, y) {
			return getAllHandles().find(h =>
				x >= h.x - handleSize / 2 && x <= h.x + handleSize / 2 &&
				y >= h.y - handleSize / 2 && y <= h.y + handleSize / 2
				//xが数値以上数値以下かつyが数値以上数値以下
			)?.dir || '';//論理和（OR演算子）||は、expr1 || expr2 expr1 を true と見ることができる場合は、expr1 を返します。そうでない場合は、expr2 を返す
		}

		//トリミングボックスの範囲内であればtrueを返す
		function inRect(x, y) {
			return (
				x >= cropRect.x &&
				x <= cropRect.x + cropRect.w &&
				y >= cropRect.y &&
				y <= cropRect.y + cropRect.h
			);
		}

		function getPosFromEvent(e) {
			const rect = canvasModal.getBoundingClientRect();//要素の現在のビューポート（ブラウザの表示領域）に対する相対位置とサイズを示す DOMRect オブジェクトを返す
			if (e.touches && e.touches.length > 0) {
				return {
					//クライアン座標からcanvasの左上の座標を引くことでcanvasの左上を(0,0)とした座標を取得
					x: e.touches[0].clientX - rect.left,
					y: e.touches[0].clientY - rect.top,
				};
			} else {
				return {
					x: e.clientX - rect.left,
					y: e.clientY - rect.top,
				};
			}
		}

		//カーソルの形状を変更
		function setCursor(e) {
			const pos = getPosFromEvent(e);
			const dir = getHandleAt(pos.x, pos.y);
			if (dir && directionToCursor[dir]) {
				canvasModal.style.cursor = directionToCursor[dir];
			} else if (inRect(pos.x, pos.y)) {
				canvasModal.style.cursor = "move";
			} else {
				canvasModal.style.cursor = "default";
			}
		}

		function startDrag(e) {
			e.preventDefault();//イベントのデフォルト動作（例えばテキストの選択や画面のスクロールなど）を防止。

			const pos = getPosFromEvent(e);
			const handle = getHandleAt(pos.x, pos.y);
			if (handle) {
				isResizing = true;
				resizeDir = handle;
			} else if (inRect(pos.x, pos.y)) {
				isDragging = true;
				dragOffsetX = pos.x - cropRect.x;//方角の8つの点からの距離
				dragOffsetY = pos.y - cropRect.y;//方角の8つの点からの距離
			}
		}

		function moveDrag(e) {
			if (!isDragging && !isResizing) {//マウスクリックして移動中（ドラッグ）以外の時実行 どちらかが!trueになるのはマウスクリックして移動中（ドラッグ）中のみ
				setCursor(e);
				return;
			}
			e.preventDefault();
			const pos = getPosFromEvent(e);

			if (isDragging) {
				//pos.x - dragOffsetXで移動先のトリミング範囲の左上のX座標と、canvasModal.width - cropRect.wでキャンバスの右端からトリミング範囲の幅を引いた値を比較して小さい方を採用し（canvasModal.width - cropRect.wより大きい場合はトリミング範囲が場外になるので）、さらに0と比較して大きい方を採用することで、X座標がマイナスにならないようにしている（画像外に出ないように）
				cropRect.x = Math.max(0, Math.min(canvasModal.width - cropRect.w, pos.x - dragOffsetX));
				cropRect.y = Math.max(0, Math.min(canvasModal.height - cropRect.h, pos.y - dragOffsetY));
			} else if (isResizing) {
				let minW = handleSize, minH = handleSize;
				let x = cropRect.x, y = cropRect.y, w = cropRect.w, h = cropRect.h;
				switch (resizeDir) {
					case 'nw':
						w += x - pos.x; h += y - pos.y; x = pos.x; y = pos.y; break;
					case 'n':
						h += y - pos.y; y = pos.y; break;
					case 'ne'://xは左上の座標なので変わらない
						w = pos.x - x; h += y - pos.y; y = pos.y; break;
					case 'e':
						w = pos.x - x; break;
					case 'se'://xとyは左上の座標なので変わらない
						w = pos.x - x; h = pos.y - y; break;
					case 's':
						h = pos.y - y; break;
					case 'sw':
						w += x - pos.x; x = pos.x; h = pos.y - y; break;
					case 'w':
						w += x - pos.x; x = pos.x; break;
				}
				// 最小サイズ制御
				w = Math.max(w, minW);
				h = Math.max(h, minH);

				// 画像外に出ないよう制御
				if (x < 0) { w += x; x = 0; }//widthを飛び出ている分足す
				if (y < 0) { h += y; y = 0; }
				if (x + w > canvasModal.width) w = canvasModal.width - x;//widthは最大でもcanvasModal.widthまでの大きさになるべきなので、xが0から動いた分を引くことで調整
				if (y + h > canvasModal.height) h = canvasModal.height - y;
				cropRect = { x, y, w, h };
			}
			//ここまでで計算しかしてないので、draw();で実際に描画する
			draw();
		}

		//ブーリアン値を初期状態に戻す
		function endDrag(e) {
			isDragging = false;
			isResizing = false;
		}


		canvasModal.addEventListener('mousedown', startDrag);//マウスボタン押下 (ドラッグの開始時にも)トリミングとハンドル範囲内以外なら何もしない
		canvasModal.addEventListener('mousemove', moveDrag);//マウス移動
		canvasModal.addEventListener('mouseup', endDrag);//マウスボタンを離す
		canvasModal.addEventListener('mouseleave', endDrag);//マウスがキャンバスから離れた

		canvasModal.addEventListener('touchstart', startDrag);
		canvasModal.addEventListener('touchmove', moveDrag);
		canvasModal.addEventListener('touchend', endDrag);
		canvasModal.addEventListener('touchcancel', endDrag);//システム（着信やアラーム）などによってタッチ操作がキャンセル

		document.getElementById('crop-button').addEventListener('click', () => {
			resultCanvas.width = cropRect.w;
			resultCanvas.height = cropRect.h;
			resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
			resultCtx.drawImage(
				img,
				cropRect.x * (img.width / drawWidth), // 元画像の切り取り開始位置の左上のX座標
				cropRect.y * (img.height / drawHeight),
				cropRect.w * (img.width / drawWidth),// 描画する幅（切り取りサイズと同じなのでリサイズなし）
				cropRect.h * (img.height / drawHeight),
				0,//キャンバス上に描画する左上の座標
				0,
				cropRect.w,//描画先での幅（拡大/縮小）
				cropRect.h
			);
			updateInputFileFromCanvas(resultCanvas);
			modalBackground.style.display = 'none';
		});

	});

//input type="file"の内容をCanvasの内容で更新する関数(これ以外の方法は無さそう)
	function updateInputFileFromCanvas(resultCanvas) {
		resultCanvas.toBlob(blob => {//blobはBinary Large Object
			const file = new File([blob], "cropped.png", { type: "image/png" });
			const dataTransfer = new DataTransfer();//標準APIのDataTransferオブジェクトを作成し、ファイルを一時的に格納できる箱を用意。
			dataTransfer.items.add(file);
			inputElem = document.getElementById('input-img-import');
			inputElem.files = dataTransfer.files;//input要素のfilesプロパティにDataTransferオブジェクトのfilesプロパティを代入することで、input要素の選択されたファイルを更新できる
		});
	}


	//カラーピッカー処理
	const colorpicker = document.getElementById('colorpicker');
	const textInputsArray = document.querySelectorAll('input[type="text"]');

	// カラーピッカーの値が変わったら文字色を更新
	colorpicker.addEventListener('input', () => {

		textInputsArray.forEach(input => {
			input.style.color = colorpicker.value;
			input.style.webkitTextFillColor = colorpicker.value;
		});

		inputFreeComment.style.color = colorpicker.value;
		inputFreeComment.style.webkitTextFillColor = colorpicker.value;
	});


	//フォント変更処理
	const selector = document.getElementById('fontselector');
	let fontName;
	selector.addEventListener('change', function () {
		fontName = this.value;

		const style = document.createElement('style');
		style.innerHTML = `
  input::placeholder,textarea::placeholder,input[type="text"],textarea {
    font-family: ${fontName} !important;
  }
`;
		document.head.appendChild(style);
	});


	//Canvasの初期画像処理
	const baseImg = new Image();
	//Image オブジェクトに画像URLを設定すると、ブラウザはその画像ファイルのダウンロードを開始
	baseImg.src = imgSrc;
	baseImg.crossOrigin = 'anonymous'; // クロスオリジン回避(CORS)

	//画像の読み込みが完了したときに発生するイベントハンドラ
	baseImg.onload = () => {
		canvas.width = baseImg.width;
		canvas.height = baseImg.height;
	};


	// 画像生成ボタンが押された時の処理
	const generateBtn = document.getElementById('generate-button');
	const downloadLink = document.getElementById('downloadlink');
	const downloadBtn = document.getElementById('download-button');


	const inputText = document.getElementById('input-blader-name');
	const inputAge = document.getElementById('input-age');
	const inputGender = document.getElementById('input-gender');
	const inputLocation = document.getElementById('input-location');
	const inputGeneration = document.getElementById('input-generation');
	const inputMaxPower = document.getElementById('input-max-power');
	const inputLauncher = document.getElementById('input-launcher');
	const inputTournament = document.getElementById('input-tournament');
	const inputFreeComment = document.getElementById('input-free-comment');

	generateBtn.addEventListener('click', () => {
		//プロフィール画像処理
		const file = inputImg.files[0];

		// 画像を取り込んでいない場合処理終了
		if (!file) {
			alert('画像を選択してください。');
			return;
		}

		const text = inputText.value.trim();
		const textAge = inputAge.value.trim();
		const textGender = inputGender.value.trim();
		const textLocation = inputLocation.value.trim();
		const textGeneration = inputGeneration.value.trim();
		const textMaxPower = inputMaxPower.value.trim();
		const textLauncher = inputLauncher.value.trim();
		const textTournament = inputTournament.value.trim();
		const textFreeComment = inputFreeComment.value.split('\n'); // 改行で分割して配列にする;

		generateBtn.style.display = 'none';
		reEditBtn.style.display = 'block';

		//Canvasに画像を描画
		ctx.drawImage(baseImg, 0, 0);


		// 文字スタイル設定
		ctx.font = `60px ${fontName}`;
		ctx.fillStyle = colorpicker.value;
		ctx.textAlign = 'start';//文字の位置は下記の数値が文字列のどこに位置するか

		// 真ん中に記入する場合ctx.fillText(text, canvas.width / 2, canvas.height / 2);
		// ctx.fillText(text, 10, 100);
		ctx.fillText(text, canvas.width * 0.06, canvas.height * 0.15);
		ctx.fillText(textLocation, canvas.width * 0.06, canvas.height * 0.25);
		ctx.fillText(textAge, canvas.width * 0.06, canvas.height * 0.4);
		ctx.fillText(textGender, canvas.width * 0.36, canvas.height * 0.4);
		ctx.fillText(textMaxPower, canvas.width * 0.66, canvas.height * 0.4);

		ctx.fillText(textGeneration, canvas.width * 0.06, canvas.height * 0.55);

		ctx.fillText(textLauncher, canvas.width * 0.06, canvas.height * 0.7);
		ctx.fillText(textTournament, canvas.width * 0.56, canvas.height * 0.7);

		//フリーコメントは1行ごとに場所を指定する
		textFreeComment.forEach((line, index) => {
			ctx.fillText(line, canvas.width * 0.06, canvas.height * 0.04 * index + canvas.height * 0.8); // 左寄せ10px、縦位置調整
		});

		//Canvasで文字を表示するので、input要素を非表示にする
		textInputsArray.forEach(input => {
			input.style.display = 'none';
		});

		// アイコン画像選択ボタンを非表示にする
		imgInputLabel.style.display = 'none';

		inputFreeComment.style.display = 'none';

		// FileReaderでローカル画像を読み込む
		const reader = new FileReader();

		//読み込み開始、読み込み完了後にreader.onloadイベントが発火し、e.target.resultにBase64形式のデータURLが格納
		reader.readAsDataURL(file);

		reader.onload = function (e) {
			// ローカル画像を読み込んで重ねる
			const overlayImg = new Image();
			overlayImg.src = e.target.result;

			overlayImg.onload = function () {
				// サイズ調整したい場合はdrawImageの引数で変更可能
				// ctx.drawImage(overlayImg, 50, 50, overlayImg.width, overlayImg.height);
				ctx.drawImage(overlayImg, canvas.width * 0.618333, canvas.height * 0.09, canvas.width * 0.333, canvas.height * 0.25);

				// Canvas画像表示
				//canvas要素に描画された内容を「PNG形式のBase64データURL」に変換 画像のホスト側がCORS許可ヘッダー出していないと処理が動かない
				const canvas_data_url = canvas.toDataURL('image/png');

				//imgタグのsrcをcanvasで生成したものに変更する
				resultImg.src = canvas_data_url;

				// ダウンロードリンク設定
				downloadLink.href = canvas_data_url;
				downloadBtn.style.display = 'inline';
			};
		};
	});


	// 再編集ボタンが押されたら実行
	const reEditBtn = document.getElementById('re-edit-button');

	reEditBtn.addEventListener('click', () => {

		generateBtn.style.display = 'block';
		reEditBtn.style.display = 'none';

		inputFreeComment.style.display = 'inline';
		imgInputLabel.style.display = 'inline-block';


		textInputsArray.forEach(input => {
			input.style.display = 'inline';

			//inputを再表示させたことによってブラウザ履歴（オートフィル）で入力された部分の背景画像が透明にならないのを解消する
			const val = input.value;
			input.value = "";
			input.value = val;
		});

		// ctx.fillTextの内容を消す
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		//画像をcanvasから背景画像に戻す
		resultImg.src = imgSrc;

		downloadBtn.style.display = 'none';
	});




</script>

<!-- ↓このページ独自のCSS追加 -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
<style>
	@font-face {
		font-family: 'DotWeb';
		src: url('https://shinamoso.github.io/RepositoryForVSCode/font/Nosutaru-dotMPlusH-10-Regular_Subsetting.woff2') format('woff2');
		/* https://logotype.jp/nosutaru-dot.html */
	}

	body {
		margin: 0;
	}

	@media screen and (min-width: 900px) {
		#main-container {
			display: flex;
		}
	}




	#left-content {
		position: relative;
	}

	#img-import-content {
		position: absolute;
		top: 20%;
		left: 68%;
		width: 25%;
		height: 10%;
		overflow: hidden;
		font-size: 10px !important;
		padding: 0;
	}

	#label-img-import {
		display: inline-block;
		padding: 10px 20px;
		background-color: white;
		color: black;
		cursor: pointer;
		font-weight: bold;
		font-size: 16px;
		user-select: none;
		border: 1px solid #333;
	}

	input[type="text"],
	textarea {
		position: absolute;
		background-color: transparent;
		border: transparent;
		color: #3bbcdc;
		font-weight: bold;
		font-size: 30px;
	}

	/* ブラウザの履歴（オートフィル）から入力された場合も文字色を変える */
	input:-webkit-autofill,
	input:-webkit-autofill:hover,
	input:-webkit-autofill:focus {
		-webkit-text-fill-color: #3bbcdc;
		-webkit-box-shadow: 0 0 0 1000px transparent inset !important;
		/*「inset」は内側に影を描く 「0 0 0 1000px」 水平・垂直の影のオフセットとぼかしの半径,影の拡張範囲*/
		transition: background-color 5000s ease-in-out 0s;
		/* ease-in-out はアニメーションの速度変化を緩やかに始まりゆっくり終わる設定、0s はアニメーション開始の遅延時間をなし 変化の期間を5000秒にすることで自動的に付く背景を無しにしている */
		/* background-color: transparent !important; */
	}

	#input-blader-name {
		position: absolute;
		top: 12%;
		left: 6%;
		height: 4%;
		width: 53%;
	}

	#input-location {
		position: absolute;
		top: 23%;
		left: 6%;
		height: 4%;
		width: 53%;
	}

	#input-age {
		position: absolute;
		top: 38%;
		left: 6%;
		height: 4%;
		width: 26%;
	}

	#input-gender {
		position: absolute;
		top: 38%;
		left: 37%;
		height: 4%;
		width: 26%;
	}

	#input-max-power {
		position: absolute;
		top: 38%;
		left: 67%;
		height: 4%;
		width: 26%;
	}

	#input-generation {
		position: absolute;
		top: 50%;
		left: 6%;
		height: 4%;
		width: 87%;
	}

	#input-launcher {
		position: absolute;
		top: 66%;
		left: 6%;
		height: 4%;
		width: 42%;
	}

	#input-tournament {
		position: absolute;
		top: 66%;
		left: 52%;
		height: 4%;
		width: 42%;
	}

	#input-free-comment {
		position: absolute;
		top: 77%;
		left: 6%;
		height: 17%;
		width: 87%;
	}

	#colorpicker-wrapper {
		margin: 10px;
	}

	#colorpicker {
		width: 150px;
		height: 50px;
		border: none;
		padding: 0;
		cursor: pointer;
	}

	#colorpicker-label {
		font-size: 30px;
	}

	#fontselector-wrapper {
		margin-bottom: 10px;
		font-size: 30px;
	}

	select {
		font-size: 24px;
		height: 48px;
		padding: 6px 12px;
	}

	button {
		font-size: 30px;
		background-color: #333;
		box-shadow: 5px 5px 0 0 rgba(0, 0, 0, 0.3);
		border-radius: 20px;
		color: white;
		border: 1px solid #333;
		padding: 15px 30px;
		cursor: pointer;
		transition: all 0.2s ease-in-out;
		margin: 10px;
	}

	#button-content {
		display: flex;
	}

	#downloadlink {
		color: white;
		text-decoration: none;
	}

	@media screen and (max-width: 700px) {
		#modal-container {
			/* width: 100%; */
			height: 100vh;
		}
	}


	.modal {
		position: fixed;
		z-index: 1;/*数字が大きい方が上*/
		left: 0;
		top: 0;
		height: 100%;
		width: 100%;
		overflow: auto;/*ボックスに収まらない内容をどう表示するかは、ユーザーエージェントに依存する。内容が収まらない場合には、スクロールバーなどが表示される*/
		background-color: rgba(0, 0, 0, 0.5);/*モーダル外の背景色*/
	}

	#modal-content {
		background-color: #f4f4f4;
		margin: 2% auto;
		width: 90%;
		/* min-height: 85%; */
		box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2), 0 7px 20px 0 rgba(0, 0, 0, 0.17);
		animation-name: modalopen;
		animation-duration: 1s;
	}

	@keyframes modalopen {
		from {
			opacity: 0
		}

		to {
			opacity: 1
		}
	}

	#modal-header h1 {
		margin: 1rem 0;
	}

	#modal-header {
		background: lightblue;
		padding: 3px 15px;
		display: flex;
		justify-content: space-between;
	}

	.modalClose {
		font-size: 2rem;
	}

	.modalClose:hover {
		cursor: pointer;
	}

	#modal-body {
		padding: 10px 20px;
		/* height: 90%; */
		color: black;
	}

	#canvas-modal {
		border: 1px solid #333;
		touch-action: none;
		cursor: crosshair;
		z-index: 2;
	}

	/* 900px以下の画面幅の場合 */
	@media screen and (max-width: 900px) {
		#result-img {
			width: 100%;
		}


	}

	@media (min-width: 425px) and (max-width: 900px) {

		input[type="text"],
		textarea {
			font-size: 24px;
		}

		#label-img-import {
			font-size: 12px;
			padding: 5px 10px;
		}
	}

	@media screen and (max-width: 424px) {

		#modal-header h1 {
			font-size: 18px;
		}

		#modal-content {
			width: 95%;
		}

		input[type="text"],
		textarea {
			font-size: 20px;
		}

		#label-img-import {
			font-size: 10px;
			padding: 5px 10px;
		}

		#colorpicker-label,
		#fontselector-wrapper,
		button {
			font-size: 20px;
		}
	}
</style>

</html>